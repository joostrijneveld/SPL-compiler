\documentclass[a4paper]{article}
\usepackage[english]{babel} % for english wordwrapping
\usepackage{a4wide} % for a4 paper and images
\usepackage[parfill]{parskip} % no indents on new par, but new lines
\usepackage[colorlinks=true, linkcolor=black, urlcolor=black, citecolor=black]{hyperref} % to make labels clickable
\usepackage{listings} % for grammar rules
\usepackage{bussproofs} % for typing rules
\usepackage{amssymb}

\EnableBpAbbreviations

% set lstset for SPL
\lstset{language=C}
\lstset{
 numbers=left,
 morekeywords={Void, Int, Bool, .fst, .snd, .hd, .tl}
 basicstyle=\small\normalfont\sffamily,    % the size of the fonts that are used for the code
 }

\title{Compiler Construction part 2: Semantic analysis}
\author{Joost Rijneveld, s4048911\\Koen van Ingen, s4058038}
\date{}
\begin{document}

\maketitle

\section{Overview}
{\bf Usage:} {\tt python src/toolchain.py spl/assignmentprogs.spl}

Our submission contains the following files:

\begin{description}
	\item[src/toolchain.py] The toolchain calls the scanner, parser, printer and type checker consecutively, passing the result from one on to the next. This is the script you need to execute to parse and print an {\tt .spl} source file.
	\item[src/scanner.py] This file contains the scanner. The scanner expects a filename and produces a list of Tokens that can then be passed on to the parser. {\tt Token} objects contain a position (line / col) to indicate where the token was found, for future error handling.
	\item[src/parser.py] The parser expects a list of {\tt Token} objects, as produced by the scanner. It then outputs the root of a parse tree (a {\tt Node} object). Grammar rules can be mapped one-to-one to {\tt parse\_} functions, some of which are generated based on a blueprint function that is partially applied (the {\tt tail\_recursion} function). When the parser runs into an error, it prints the expected literal (if applicable) and the line and column number.
	\item[src/semanticanalysis.py] This is the type and function binding checker. It will check for type errors and function binding errors, when it is called with the {\tt check\_binding} function. It expects a tree that can be generated with {\tt parser.py}. A dictionary with a symbol table can be given as an optional argument. The {\tt Symbol} class is also defined in this file. We currently use this optional argument to give the function a symbol table with the two predifend functions: {\tt isEmpty} and {\tt print}. 
	\item[src/printer.py] This script expects a parse tree as provided by the parser, and prints formatted (and aligned) SPL source code to stdout.
%	\item[spl/assignmentprogs.spl] The example SPL programs as provided in the assignment.
	\item[spl/*] This folder contains the 10 sample SPL programs, as required by the assignment. All of them parse, print and type check fine. Some of them have wrong statements (with type errors) in comments, which can be enabled to trigger type check errors. In section \ref{examples}, we explain these programs and their result in more details.
	\item[grammar.txt] This file contains the modified grammar which we used for our parser.
\end{description}

\newpage % vooruit dan :)
\section{Used grammar}
% TODO misschien wat netter formatten? Ook language=haskell moet beter kunnen
\lstinputlisting[numbers=none, language=haskell]{../../grammar.txt}

\newpage % vooruit dan :)
\section{Scoping rules}
% Ja geen idee, random verhaaltje hier doen? Of formele dingen?


\newpage % vooruit dan :)
\section{Typing rules}
% Joost: zet ff je fijne package hier neer

{\sf
\begin{prooftree}
  \AXC{$b \in$ {\tt \{True, False\}}}
  \RightLabel{\sc \small (Bool)}
  \UIC{$\Gamma \vdash b$ : {\tt Bool}}
\end{prooftree}
}

{\sf
\begin{prooftree}
  \AXC{$i \in \mathbb{N}$}
  \RightLabel{\sc \small (Int)}
  \UIC{$\Gamma \vdash i$ : {\tt Int}}
\end{prooftree}
}

{\sf
\begin{prooftree}
  \AXC{$\Gamma \vdash e_1 : \sigma_1$}
  \AXC{$\Gamma \vdash e_2 : \sigma_2$}
  \RightLabel{\sc \small (Tuple)}
  \BIC{$\Gamma \vdash (e_1, e_2) : (\sigma_1, \sigma_2)$}
\end{prooftree}
}

{\sf
\begin{prooftree}
  \AXC{$\odot : \sigma_1 \rightarrow \sigma_2 \rightarrow \tau$}
  \AXC{$\Gamma \vdash e_1 : \sigma_1$}
  \AXC{$\Gamma \vdash e_2 : \sigma_2$}
  \RightLabel{\sc \small (Bin op)}
  \TIC{$\Gamma \vdash e_1 \odot e_2 : \tau$}
\end{prooftree}
}

{\sf
\begin{prooftree}
  \AXC{$\Gamma \vdash e_1 : \sigma$}
  \AXC{$\Gamma \vdash e_2 : [\sigma]$}
  \RightLabel{\sc \small (Cons)}
  \BIC{$\Gamma \vdash (e_1, e_2) : [\sigma]$}
\end{prooftree}
}

\newpage % vooruit dan :)
\section{Example tests}
\label{examples}

\subsection{General function application}
The file {\tt fnapplication.spl} is an example of a program that tests the function application and whether the number and type of arguments of the function call matches with the ones in the header.
\lstinputlisting{spl/fnapplication.spl}
The call at line 7 is here the only correct function call in this program: only in this case do the number and type of arguments match. In the other cases, we get an error: 

% Verbatim doen hier?
\begin{verbatim}
Exception: [Line 8:2] Incompatible number of arguments for function 'foo'.
  Arguments expected: 1
    Arguments found: 0
\end{verbatim}

As a result, we get the following pretty-printed program and symbol table: 

\begin{verbatim}
Void foo(Int x)
{
        [Int] xs = (x : []);
        return;
}
Void call_foo()
{
        foo(5);
}

==============================================================
Position     Name            Type            Argtypes            
--------------------------------------------------------------
0:0          print           'Void'          't'                 
1:6          foo             'Void'          'Int'               
0:0          isEmpty         'Bool'          ['t']               
6:6          call_foo        'Void'                              
==============================================================
==============================================================
Position     Name            Type            Argtypes            
--------------------------------------------------------------
0:0          isEmpty         'Bool'          ['t']               
1:14         x               'Int'           None                
0:0          print           'Void'          't'                 
2:8          xs              ['Int']         None                
1:6          foo             'Void'          'Int'               
6:6          call_foo        'Void'                              
==============================================================
==============================================================
Position     Name            Type            Argtypes            
--------------------------------------------------------------
0:0          print           'Void'          't'                 
1:6          foo             'Void'          'Int'               
0:0          isEmpty         'Bool'          ['t']               
6:6          call_foo        'Void'                              
==============================================================
\end{verbatim}
In this output refers the first table to the global symbol table, the second to the function {\tt foo()} (which off course also includes all the global symbols). The third table refers to the function {\tt call\_foo()}

\subsection{Assignments with empty lists}
Because empty lists can cause a lot of troubles with type checking (since can match on most generic types, but not all of them), we thought it might be a good idea to include some test variable declarations with empty lists as an example program. This can be found in {\tt emptylists.spl}. 
\lstinputlisting{spl/emptylists.spl}
The first one should obviously go right, because every element in the list can be map to a list of integers, which will result in a list of list of integers. The second one, this is not the case: we expect a list of integers, but a list with 2 empty lists will be mapped to a list of a list of something, and thus we get an error here: 
\begin{verbatim}
Exception: [Line 2:7] Invalid assignment for id b
  Expected expression of type: ['Int']
    But got value of type: [[None]]
\end{verbatim}
The examples on line 4 and 5 should go right, since in both cases, the empty list can be mapped to either a list of list of Int or a generic list of list of `a'. Example 5 will fail because ???

This is the pretty-printed output and the symbtol table of this program: 
\begin{verbatim}
[[Int]] a = ([] : ((5 : []) : []));
[[Int]] c = ([] : []);
[[a]] d = ([] : []);
[([Bool],[Int])] f = (([], (5 : [])) : (((True : []), []) : []));

==============================================================
Position     Name            Type            Argtypes            
--------------------------------------------------------------
1:9          a               [['Int']]       None                
3:9          c               [['Int']]       None                
0:0          isEmpty         'Bool'          ['t']               
4:7          d               [['a']]         None                
0:0          print           'Void'          't'                 
==============================================================
\end{verbatim}

\subsection{Function application with empty lists}
In our next example, we will combine our function application with the empty lists. The code can be found in {\tt fnonemptylists.spl}.
\lstinputlisting{spl/fnonemptylists.spl}
The call on line 5 will go right, because we give this function a list of integers, which is possible because this can be mapped to the more generic type `b'. As a result, we get a lists of integers back, which fits exactly in our variable `a' that is of type [Int]. For the call on line 6, the same holds, since the empty list fits in a list of integers. 

This is the pretty-printed output and the symbol table of this program: 
\begin{verbatim}
[b] foo([b] x)
{
        return x;
}
[Int] a = foo((5 : []));
[Int] b = foo([]);

==============================================================
Position     Name            Type            Argtypes            
--------------------------------------------------------------
0:0          print           'Void'          't'                 
5:7          a               ['Int']         None                
6:7          b               ['Int']         None                
0:0          isEmpty         'Bool'          ['t']               
1:5          foo             ['b']           ['b']               
==============================================================
==============================================================
Position     Name            Type            Argtypes            
--------------------------------------------------------------
5:7          a               ['Int']         None                
6:7          b               ['Int']         None                
0:0          isEmpty         'Bool'          ['t']               
0:0          print           'Void'          't'                 
1:13         x               ['b']           None                
1:5          foo             ['b']           ['b']               
==============================================================
\end{verbatim}

\subsection{Unbounded return types}
With this example, we want to show what happens when you try to apply an unbound return type to a concrete type. The code can be found in {\tt unboundreturntype.spl}. 
\lstinputlisting{spl/unboundreturntype.spl}
Here we can see that the function call on line 6 will go right, since we do not use the return type here. But the call on line 10 goes wrong, because the unbound `a' cannot be mapped to [Int]. If we enable this line, we get the following exception: 

\begin{verbatim}
Exception: [Line 10:11] Generic return type 'a' is not bound by arguments for function 'foo', so cannot be resolved.
\end{verbatim}

If we disable this line (by putting it in comments), we can pretty-print en show the symbol table of this program:
\begin{verbatim}
[a] foo()
{
        return [];
}
Void call_foo()
{
        foo();
}

==============================================================
Position     Name            Type            Argtypes            
--------------------------------------------------------------
0:0          print           'Void'          't'                 
1:5          foo             ['a']                               
0:0          isEmpty         'Bool'          ['t']               
5:6          call_foo        'Void'                              
==============================================================
==============================================================
Position     Name            Type            Argtypes            
--------------------------------------------------------------
0:0          print           'Void'          't'                 
1:5          foo             ['a']                               
0:0          isEmpty         'Bool'          ['t']               
5:6          call_foo        'Void'                              
==============================================================
==============================================================
Position     Name            Type            Argtypes            
--------------------------------------------------------------
0:0          print           'Void'          't'                 
1:5          foo             ['a']                               
0:0          isEmpty         'Bool'          ['t']               
5:6          call_foo        'Void'                              
==============================================================
\end{verbatim}

\subsection{Unequal comparison}
When we want to sort two lists and compare them, they should be of the same type. The program in the file {\tt unequalcomparisongenerics.spl} shows this. 
\lstinputlisting{spl/unequalcomparisongenerics.spl}
The call at line 8 will go wrong, since a returned list of integers cannot be compared with a returned lists of booleans. We will get the following error: 
\begin{verbatim}
Exception: [Line 8:18] Incompatible types for operator = 
  Types expected: 't', 't'
    Types found: ['Int'], ['Bool']
\end{verbatim}

With the empty list at line 9, everything will go right, and we get the following pretty-printed program and symbol table: 

\begin{verbatim}
[a] sort([a] list)
{
        return list;
}
Bool main()
{
        [Int] as = (1 : (2 : (3 : [])));
        [Bool] bs = (True : []);
        return (sort(as) == sort([]));
}

==============================================================
Position     Name            Type            Argtypes            
--------------------------------------------------------------
0:0          print           'Void'          't'                 
1:5          sort            ['a']           ['a']               
5:6          main            'Bool'                              
0:0          isEmpty         'Bool'          ['t']               
==============================================================
==============================================================
Position     Name            Type            Argtypes            
--------------------------------------------------------------
0:0          print           'Void'          't'                 
1:5          sort            ['a']           ['a']               
1:14         list            ['a']           None                
5:6          main            'Bool'                              
0:0          isEmpty         'Bool'          ['t']               
==============================================================
==============================================================
Position     Name            Type            Argtypes            
--------------------------------------------------------------
1:5          sort            ['a']           ['a']               
6:8          as              ['Int']         None                
0:0          isEmpty         'Bool'          ['t']               
7:9          bs              ['Bool']        None                
0:0          print           'Void'          't'                 
5:6          main            'Bool'                              
==============================================================
\end{verbatim}

\subsection{Type of operators}
Another interesting example is the use of different operators. We will show this with a program that calculates the product of the values in a list. This program can be found in {\tt product.spl}.
\lstinputlisting{spl/product.spl}
This is a rather basic program, since no generic types are used. However, we can use it to show that the *-operator expects two integers as arguments: if we replace the [Int] in the function header with [a], we get an error: 
\begin{verbatim}
Exception: [Line 5:17] Incompatible types for operator *
  Types expected: 'Int', 'Int'
  Types found: 'a', 'Int'
\end{verbatim}
With just [Int] in the header, we get the following pretty-printed program and symbol table:
\begin{verbatim}
Int product([Int] list)
{
        if (isEmpty(list))
        {
                return 1;
        }
        return (list.hd * product(list.tl));
}

==============================================================
Position     Name            Type            Argtypes            
--------------------------------------------------------------
0:0          print           'Void'          't'                 
1:5          product         'Int'           ['Int']             
0:0          isEmpty         'Bool'          ['t']               
==============================================================
==============================================================
Position     Name            Type            Argtypes            
--------------------------------------------------------------
0:0          print           'Void'          't'                 
1:21         list            ['Int']         None                
1:5          product         'Int'           ['Int']             
0:0          isEmpty         'Bool'          ['t']               
==============================================================
\end{verbatim}

\subsection{Zip and tuples}
With the zip function, we can show that we are able to handle both lists and tuples with generic types. The code of this program can be found in {\tt zip.spl}. 
\lstinputlisting{spl/zip.spl}

When we run this program, we get the following pretty-printed code and symbol table.
\begin{verbatim}
[(a,b)] zip([a] a, [b] b)
{
        if ((isEmpty(a) || isEmpty(b)))
        {
                return [];
        }
        return ((a.hd, b.hd) : zip(a.tl, b.tl));
}
Int main()
{
        [Int] ints = (1 : (2 : (3 : (4 : []))));
        [Bool] bools = (True : (False : (False : (True : []))));
        [(Int,Bool)] zipped = zip(ints, bools);
        return 1;
}

==============================================================
Position     Name            Type            Argtypes            
--------------------------------------------------------------
0:0          print           'Void'          't'                 
9:5          main            'Int'                               
0:0          isEmpty         'Bool'          ['t']               
1:9          zip             [('a', 'b')]    ['a'], ['b']        
==============================================================
==============================================================
Position     Name            Type            Argtypes            
--------------------------------------------------------------
1:18         a               ['a']           None                
1:24         b               ['b']           None                
0:0          isEmpty         'Bool'          ['t']               
1:9          zip             [('a', 'b')]    ['a'], ['b']        
0:0          print           'Void'          't'                 
9:5          main            'Int'                               
==============================================================
==============================================================
Position     Name            Type            Argtypes            
--------------------------------------------------------------
0:0          isEmpty         'Bool'          ['t']               
11:11        ints            ['Int']         None                
1:9          zip             [('a', 'b')]    ['a'], ['b']        
0:0          print           'Void'          't'                 
13:18        zipped          [('Int', 'Bool')] None                
9:5          main            'Int'                               
12:12        bools           ['Bool']        None                
==============================================================
\end{verbatim}

\subsection{Pretty printer test}
With this example, we want to show that our parser is working, and that the pretty printer will print our code in a correct way without unneeded braces. This code can be found in {\tt prettyprinttest.spl}.
\lstinputlisting{spl/prettyprinttest.spl}
When we omit one brace at the end, our parser will complain:
\begin{verbatim}
Exception: [Line 2:40] Expected ')' or ',', but got: ;
\end{verbatim}

When we compile this program, we get the following symbol table and pretty-printed code (which is much better readable):
\begin{verbatim}
Int calc(Int x, Int y, Int z)
{
        if ((((y + 1) > 0) && ((x / (y + 1)) > z)))
        {
                return ((5 * (((2 + x) - 6) + z)) + (42 % 3));
        }
        return 0;
}
Int main()
{
        return calc(1, 2, 3);
}

==============================================================
Position     Name            Type            Argtypes            
--------------------------------------------------------------
0:0          print           'Void'          't'                 
4:5          main            'Int'                               
1:5          calc            'Int'           'Int', 'Int', 'Int' 
0:0          isEmpty         'Bool'          ['t']               
==============================================================
==============================================================
Position     Name            Type            Argtypes            
--------------------------------------------------------------
1:21         y               'Int'           None                
4:5          main            'Int'                               
0:0          isEmpty         'Bool'          ['t']               
1:28         z               'Int'           None                
0:0          print           'Void'          't'                 
1:14         x               'Int'           None                
1:5          calc            'Int'           'Int', 'Int', 'Int' 
==============================================================
==============================================================
Position     Name            Type            Argtypes            
--------------------------------------------------------------
0:0          print           'Void'          't'                 
1:5          calc            'Int'           'Int', 'Int', 'Int' 
4:5          main            'Int'                               
0:0          isEmpty         'Bool'          ['t']               
==============================================================
\end{verbatim}

\newpage % vooruit dan :)
\section{Division of work}

\end{document}
